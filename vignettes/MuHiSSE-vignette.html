<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Background</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Background</h2>

<p>This tutorial gives some basic information on how to set up and execute parameter estimates when using MuHiSSE (Nakov et al., 2018). </p>

<p>In Nakov et al. (2018), we extended the HiSSE and CID model framework to handle a four-state case, representing correlated evolution between two binary characters. Note that a mulitstate version of HiSSE is available in RevBayes (based on its manual and conversations with Sebastian Höhna), in <code>SecSSE</code> (Herrera-Alsina et al., 2018), and as part of the model set described in Caetano et al. (2018). Our character state combinations were comprised of marine and planktonic (MP, or state combination \(00\)), marine and benthic (MB, or \(01\)), freshwater and planktonic (FP, or \(10\)), and freshwater and benthic (FB, or \(11\)). As with <code>hisse</code>, rather than optimizing \(\lambda_i\) and \(\mu_i\) separately, <code>MuHiSSE</code> optimizes transformations of these variables. Again, we let \(\tau_i = \lambda_i+\mu_i\) define &ldquo;net turnover&rdquo;, and we let \(\epsilon_i = \mu_i / \lambda_i\) define the &ldquo;extinction fraction&rdquo;. This reparameterization alleviates problems associated with over-fitting when \(\lambda_i\) and \(\mu_i\) are highly correlated, but both matter in explaining the diversity pattern (see discussion of this issue in Beaulieu and O&#39;Meara 2016). The number of free parameters in the model for both net turnover and extinction fraction are specified as index vectors provided to the function call. Each vector contains four entries that correspond to rates associated with the observed states (0 or 1) and the hidden states (A or B). They are always ordered as follows for a given hidden state, \(i\): \(00_i\), \(01_i\), \(10_i\), \(11_i\). </p>

<p>The set of models included range from (1) the &ldquo;trivial null&rdquo; model that assume no variation in diversification, to (2) a multistate speciation and extinction model (MuSSE; FitzJohn 2012) that linked diversification rates to the four character states, but assumed no variation within regimes, to (3) multistate-dependent speciation and extinction models with hidden traits (MuHiSSE) and (4) a set of multistate character-independent models (MuCID) with increasing numbers of hidden traits (MuCID2 through MuCID8). The most complex MuCID8 model has, at it&#39;s most complex, eight parameters for turnover and eight parameters for extinction fraction, matching the complexity of the MuHiSSE model, but with diversification parameters unlinked to the observed character states. For any model, we allow the transition rates between alternative state combinations to differ (e.g., \(q_{MB\rightarrow MP} \ne q_{MP\rightarrow MB}\)), or constrained to be equal (e.g., \(q_{MB\rightarrow MP} = q_{MP\rightarrow MB}\)). In the analyses presented in Nakov et al. (2018), we disallowed dual transitions (e.g., \(q_{MB\rightarrow FP} = 0\)), though this need not always be the case.</p>

<p>Below I will demonstrate how to set up various models, and how the likelihoods compare against those from <code>diversitree</code> whenever possible. In the end, I will also show how a three-state model can be set up from MuHiSSE and compare the likelihoods against the three-state MuSSE implemented in GeoHiSSE. However, before getting started, be sure to load the <code>hisse</code> and <code>diversitree</code> packages:</p>

<pre><code class="r">suppressWarnings(library(hisse))
suppressWarnings(library(diversitree))
</code></pre>

<h2>Simulating a practice data set</h2>

<p>Here I will simulate a simple four-state model using <code>diversitree</code>.</p>

<pre><code class="r">pars &lt;- c(.1,  .15,  .2, .1, # lambda 1, 2, 3, 4
.03, .045, .06, 0.03, # mu 1, 2, 3, 4
.05, .05, .00,        # q12, q13, q14
.05, .00, .05,     # q21, q23, q24
.05, .00, .05,     # q31, q32, q34
.00, .05, .05)
set.seed(2)
phy &lt;- tree.musse(pars, 30, x0=1)
states &lt;- phy$tip.state
</code></pre>

<p>Now let&#39;s get the likelihood using the same parameters we used to simulate the data:</p>

<pre><code class="r">lik &lt;- make.musse(phy, states, 4)
#lik &lt;- make.musse(phy, states, 3)
diversitree.free = lik(pars)
print(diversitree.free)
</code></pre>

<pre><code>## [1] -102.4265
</code></pre>

<p>Now we can use machinery inside MuHiSSE to demonstrate that we generate the same likelihood. Unfortunately, it takes a little bit of code to get everything into the right format to run properly. This is what is shown below. Note, too, that I am transforming \(\lambda_i\) and \(\mu_i\) into turnover and extinction fraction:</p>

<pre><code class="r">states &lt;- data.frame(phy$tip.state, phy$tip.state, 
                     row.names=names(phy$tip.state))
states &lt;- states[phy$tip.label,]
states.trans &lt;- states
for(i in 1:Ntip(phy)){
  if(states[i,1] == 1){
    states.trans[i,1] = 0
    states.trans[i,2] = 0
  }
  if(states[i,1] == 2){
    states.trans[i,1] = 0
    states.trans[i,2] = 1
  }
  if(states[i,1] == 3){
    states.trans[i,1] = 1
    states.trans[i,2] = 0
  }
  if(states[i,1] == 4){
    states.trans[i,1] = 1
    states.trans[i,2] = 1
  }
}
pars.hisse &lt;- c(pars[1]+pars[5],pars[2]+pars[6],pars[3]+pars[7],pars[4]+pars[8], 
                pars[5]/pars[1],pars[6]/pars[2],pars[7]/pars[3],pars[8]/pars[4], 
                0.05,0.05,0, 0.05,0,0.05, 0.05,0,.05, 0,0.05,.05)
model.vec = rep(0,384)
model.vec[1:20] = pars.hisse
phy$node.label = NULL
cache &lt;- hisse:::ParametersToPassMuHiSSE(model.vec=model.vec, hidden.states=TRUE, 
                                         nb.tip=Ntip(phy), nb.node=Nnode(phy), 
                                         bad.likelihood=exp(-500), ode.eps=0)
gen &lt;- hisse:::FindGenerations(phy)
dat.tab &lt;- hisse:::OrganizeData(states.trans, phy, f=c(1,1,1,1), hidden.states=TRUE)
hisse.constrained &lt;- hisse:::DownPassMuHisse(dat.tab, gen=gen, cache=cache, 
                                             root.type=&quot;madfitz&quot;, condition.on.survival=TRUE,
                                             root.p=NULL)
comparison &lt;- identical(round(hisse.constrained,4), round(diversitree.free,4))
print(comparison)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>The implementation is correct. However, in the above case, we did not actually use any hidden states. We can also show that the likelihoods are identical to MuSSE so as long as the dynamics are the same among all included hidden states. Here we will just use hidden states A and B:</p>

<pre><code class="r">pars.hisse &lt;- rep(c(pars[1]+pars[5],pars[2]+pars[6],pars[3]+pars[7],pars[4]+pars[8], 
                pars[5]/pars[1],pars[6]/pars[2],pars[7]/pars[3],pars[8]/pars[4], 
                0.05,0.05,0, 0.05,0,0.05, 0.05,0,.05, 0,0.05,.05, 1,rep(0,6), 1,
                rep(0,6), 1,rep(0,6), 1,rep(0,6)),2)
model.vec = rep(0,384)
model.vec[1:96] = pars.hisse
phy$node.label = NULL
cache &lt;- hisse:::ParametersToPassMuHiSSE(model.vec=model.vec, hidden.states=TRUE, 
                                         nb.tip=Ntip(phy), nb.node=Nnode(phy), 
                                         bad.likelihood=exp(-500), ode.eps=0)
gen &lt;- hisse:::FindGenerations(phy)
dat.tab &lt;- hisse:::OrganizeData(states.trans, phy, f=c(1,1,1,1), hidden.states=TRUE)
hisse.constrained &lt;- hisse:::DownPassMuHisse(dat.tab, gen=gen, cache=cache, 
                                             root.type=&quot;madfitz&quot;, condition.on.survival=TRUE,
                                             root.p=NULL)
comparison &lt;- identical(round(hisse.constrained,4), round(diversitree.free,4))
print(comparison)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Again, the likelihoods are identical and the implementation is correct. Note that the likelihood can also be calculated using the root likelihood summary procedure described by Herrera-Alsina et al. (2018). This is specified by doing <code>root.type=&quot;herr_als&quot;</code>. Note, however, that in our testing the likelihood differences are subtle, and in simulation the parameter estimates are nearly indistinguishable from the original root summary implementation of FitzJohn et al. (2009).</p>

<h2>Setting up a MuSSE model using MuHiSSE</h2>

<p>As mentioned above, the number of free parameters in the model for both net turnover and extinction fraction are specified as index vectors provided to the function call. Each vector contains four entries that correspond to rates associated with the observed states (0 or 1) and the hidden states (A or B). They are always ordered as follows for a given hidden state, \(i\): \(00_i\), \(01_i\), \(10_i\), \(11_i\). However, in this case we do not want any hidden states. But first let&#39;s set up the &ldquo;dull null&rdquo; &ndash; i.e., turnover and extinction fraction are the same for all observed state combinations. Note the &ldquo;f&rdquo; represents the sampling fraction for each observed state combination, which is a vector ordered in the same manner as for turnover and extinction fraction vectors:</p>

<pre><code class="r">turnover &lt;- c(1,1,1,1)
extinction.fraction &lt;- c(1,1,1,1)
f = c(1,1,1,1)
</code></pre>

<p>Next, we have to set up a transition matrix. There is a function provided to make this easy, and allows users to customize the matrix to fit particular hypotheses. Be sure to look at the options on this function call, for allowing diagonals and for customizing the matrix when you have character independent model. </p>

<pre><code class="r">trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=0)
print(trans.rate)
</code></pre>

<pre><code>##      (00) (01) (10) (11)
## (00)   NA    3    5    0
## (01)    1   NA    0    7
## (10)    2    0   NA    8
## (11)    0    4    6   NA
</code></pre>

<p>Now, we can call MuHiSSE and estimate the parameters under this model using the default settings:</p>

<pre><code class="r">states.trans &lt;- cbind(phy$tip.label, states.trans)
dull.null &lt;- MuHiSSE(phy=phy, data=states.trans, f=f, turnover=turnover, 
                     eps=extinction.fraction, hidden.states=FALSE, 
                     trans.rate=trans.rate)
</code></pre>

<p>If you wanted to set up a true MuSSE model, where the turnover rate parameters are unlinked across the observed state combinations, you would simply do the following:</p>

<pre><code class="r">turnover &lt;- c(1,2,3,4)
extinction.fraction &lt;- c(1,1,1,1)
MuSSE &lt;- MuHiSSE(phy=phy, data=states.trans, f=f, turnover=turnover, 
                     eps=extinction.fraction, hidden.states=FALSE, 
                     trans.rate=trans.rate)
</code></pre>

<h2>Setting up a character-dependent MuHiSSE model</h2>

<p>Setting up a character-dependent MuHiSSE model is relatively straightforward, and relies on all the same tools as above. One important thing to bear in mind, is that again, the states are ordered by state combination within each hidden state. For example, if you want two hidden states, A and B, the order of the parameters in the model is 00A, 01A, 10A, 11A, 00B, 01B, 10B, and 11B. So, in this case, we just need to specify the free parameters we want for diversification. Here we are just going assume turnover varies across the different states:</p>

<pre><code class="r">turnover &lt;- c(1,2,3,4,5,6,7,8)
extinction.fraction &lt;- rep(1, 8) 
f = c(1,1,1,1)
</code></pre>

<p>We also have to extend the transition rate matrix. This is done by specifying the number of hidden states:</p>

<pre><code class="r">trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=1)
print(trans.rate)
</code></pre>

<pre><code>##       (00A) (01A) (10A) (11A) (00B) (01B) (10B) (11B)
## (00A)    NA     3     5     0    17    NA    NA    NA
## (01A)     1    NA     0     7    NA    17    NA    NA
## (10A)     2     0    NA     8    NA    NA    17    NA
## (11A)     0     4     6    NA    NA    NA    NA    17
## (00B)    17    NA    NA    NA    NA    11    13     0
## (01B)    NA    17    NA    NA     9    NA     0    15
## (10B)    NA    NA    17    NA    10     0    NA    16
## (11B)    NA    NA    NA    17     0    12    14    NA
</code></pre>

<p>Now, we can just plug these options into MuHiSSE:</p>

<pre><code class="r">MuHiSSE &lt;- MuHiSSE(phy=phy, data=states.trans, f=f, turnover=turnover, 
                     eps=extinction.fraction, hidden.states=TRUE, 
                     trans.rate=trans.rate)
</code></pre>

<h2>Setting up a character-independent MuHiSSE model</h2>

<p>Remember, for any character-independent model, the diversification rates <em>must</em> be decoupled from the observed states. So, to do this, we simply set the diversification rates to be equal for all states for a given hidden state. Below, I will show how to do this for a character-independent model with two rate shifts in the tree:</p>

<pre><code class="r">turnover &lt;- c(1,1,1,1,2,2,2,2)
extinction.fraction &lt;- rep(1, 8) 
f = c(1,1,1,1)
</code></pre>

<p>For the transition rate matrix, I included a setting called <code>make.null</code> that simply replicates the transition model across the hidden states. This way the transition rates are not impacted by changes in the diversification rate regime &ndash; that is, \(q_{MB,A\rightarrow MP,A} = q_{MB,B\rightarrow MP,B}\). </p>

<pre><code class="r">trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=1, make.null=TRUE)
print(trans.rate)
</code></pre>

<pre><code>##       (00A) (01A) (10A) (11A) (00B) (01B) (10B) (11B)
## (00A)    NA     3     5     0     9    NA    NA    NA
## (01A)     1    NA     0     7    NA     9    NA    NA
## (10A)     2     0    NA     8    NA    NA     9    NA
## (11A)     0     4     6    NA    NA    NA    NA     9
## (00B)     9    NA    NA    NA    NA     3     5     0
## (01B)    NA     9    NA    NA     1    NA     0     7
## (10B)    NA    NA     9    NA     2     0    NA     8
## (11B)    NA    NA    NA     9     0     4     6    NA
</code></pre>

<p>Here is a how you would set up the diversification rates for models with three hidden state all the way to eight hidden states: </p>

<pre><code class="r">## Three hidden states
turnover &lt;- c(rep(1,4), rep(2,4), rep(3,4))
extinction.fraction &lt;- rep(1, 12) 
trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=2, make.null=TRUE)

## Four hidden states
turnover &lt;- c(rep(1,4), rep(2,4), rep(3,4), rep(4,4))
extinction.fraction &lt;- rep(1, 16) 
trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=3, make.null=TRUE)

## Five hidden states
turnover &lt;- c(rep(1,4), rep(2,4), rep(3,4), rep(4,4), rep(5,4))
extinction.fraction &lt;- rep(1, 20) 
trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=4, make.null=TRUE)

## Six hidden states
turnover &lt;- c(rep(1,4), rep(2,4), rep(3,4), rep(4,4), rep(5,4), rep(6,4))
extinction.fraction &lt;- rep(1, 24) 
trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=5, make.null=TRUE)

## Seven hidden states
turnover &lt;- c(rep(1,4), rep(2,4), rep(3,4), rep(4,4), rep(5,4), rep(6,4), 
              rep(7, 4))
extinction.fraction &lt;- rep(1, 28) 
trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=6, make.null=TRUE)

## Eight hidden states
turnover &lt;- c(rep(1,4), rep(2,4), rep(3,4), rep(4,4), rep(5,4), rep(6,4), 
              rep(7,4), rep(8,4))
extinction.fraction &lt;- rep(1, 32) 
trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=7, make.null=TRUE)
</code></pre>

<h2>Relationship of MuHiSSE to a three-state GeoSSE without cladogenetic changes</h2>

<p>As of June 2017, I have implemented a three-state MuSSE model as part of the model set for GeoHiSSE (see Caetano et al., 2018). If cladogenetic changes are disallowed, then the geographic model essentially reverts back to three-state MuSSE model. Below I will show how the likelihoods are equivalent between <code>diversitree</code>, <code>GeoHiSSE</code>, and <code>MuHiSSE</code> in the three-state case.</p>

<p>First, let&#39;s simulate a three-state model:</p>

<pre><code class="r">pars &lt;- c(.1,  .15,  .2,  # lambda 1, 2, 3
.03, .045, .06, # mu 1, 2, 3
.05, 0,         # q12, q13
.05, .05,       # q21, q23
0,   .05)       # q31, q32
set.seed(2)
phy &lt;- tree.musse(pars, 30, x0=1)
states &lt;- phy$tip.state
lik &lt;- make.musse(phy, states, 3)
lik.base &lt;- constrain(lik, lambda2 ~ lambda1, lambda3 ~ lambda1,
mu2 ~ mu1, mu3 ~ mu1,
q13 ~ 0, q21 ~ q12, q23 ~ q12, q31 ~ 0.03, q32 ~ q12)
</code></pre>

<p>Here is the likelihood for a maximally constrained model using <code>diversitree</code>:</p>

<pre><code class="r">diversitree.constrained = lik.base(c(.1, .03, .05))
print(diversitree.constrained)
</code></pre>

<pre><code>## [1] -111.1472
</code></pre>

<p>Now, let&#39;s compare the likelihood using a three-state model in <code>GeoHiSSE</code>:</p>

<pre><code class="r">states &lt;- data.frame(phy$tip.state, phy$tip.state, row.names=names(phy$tip.state))
states &lt;- states[phy$tip.label,]
states[states[,1]==3,] = 4
pars.hisse &lt;- c(0.1, 0.1, 0.1, 0.03, 0.03, 0.03, 0.05, 0, 0.05, 0.05, 0, 0.05)
model.vec = rep(0,120)
model.vec[1:12] = pars.hisse
phy$node.label = NULL
cache &lt;- hisse:::ParametersToPassMuSSE(phy, states[,1], model.vec, f=c(1,1,1), hidden.states=&quot;TEST1&quot;)
geosse.constrained &lt;- hisse:::DownPassMusse(phy, cache, hidden.states=FALSE, 
                                            root.type=&quot;madfitz&quot;, condition.on.survival=TRUE,
                                            root.p=NULL)
comparison &lt;- identical(round(geosse.constrained,4), round(diversitree.constrained,4))
print(comparison)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>We can show that you can obtain the same likelihood using <code>MuHiSSE</code>. Warning: as before it&#39;s a bit convoluted to format the data properly, but it can be done:</p>

<pre><code class="r">states.trans &lt;- states
for(i in 1:Ntip(phy)){
  if(states[i,1] == 1){
    states.trans[i,1] = 0
    states.trans[i,2] = 0
  }
  if(states[i,1] == 2){
    states.trans[i,1] = 0
    states.trans[i,2] = 1
  }
  if(states[i,1] == 4){
    states.trans[i,1] = 1
    states.trans[i,2] = 0
  }
}
pars.hisse &lt;- c(0.1+0.03,0.1+0.03,0.1+0.03,0, 
                0.03/0.1,0.03/0.1,0.03/0.1,0,
                0.05,0,0, 0.05,0.05,0, 0.03,0.05,0, 0,0,0)
model.vec = rep(0,384)
model.vec[1:20] = pars.hisse
phy$node.label = NULL
cache &lt;- hisse:::ParametersToPassMuHiSSE(model.vec=model.vec, hidden.states=TRUE, 
                                         nb.tip=Ntip(phy), nb.node=Nnode(phy), 
                                         bad.likelihood=exp(-500), ode.eps=0)
gen &lt;- hisse:::FindGenerations(phy)
dat.tab &lt;- hisse:::OrganizeData(states.trans, phy, f=c(1,1,1,0), hidden.states=TRUE)
muhisse.constrained &lt;- hisse:::DownPassMuHisse(dat.tab, gen=gen, cache=cache, 
                                             root.type=&quot;madfitz&quot;, condition.on.survival=TRUE,
                                            root.p=NULL)
comparison &lt;- identical(round(muhisse.constrained,4), round(diversitree.constrained,4))
print(comparison)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>As you can see, in the absence of hidden states, all three implementations provide identical likelihoods.</p>

<p>It is also easy to show how you would set up a three-state model using MuHiSSE. This may be beneficial with rather large trees. With <code>MuHiSSE</code>, as well as <code>fGeoHiSSE</code>, I&#39;ve implemented a much more efficient and rather fast tree traversal algorithm. Eventually, both functions will allow for multicore processing during the tree traversal stage. </p>

<p>For this example, note that we are going to assume we do not have a fourth state (i.e., \(11\)).</p>

<pre><code class="r">turnover &lt;- c(1,2,3,0)
extinction.fraction &lt;- c(1,1,1,0)
f = c(1,1,1,0)
</code></pre>

<p>Next, we have to generate, and then modify the transition rate matrix:</p>

<pre><code class="r">trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=0)
print(trans.rate)
</code></pre>

<pre><code>##      (00) (01) (10) (11)
## (00)   NA    3    5    0
## (01)    1   NA    0    7
## (10)    2    0   NA    8
## (11)    0    4    6   NA
</code></pre>

<p>We can use the <code>ParDrop()</code> function to remove transitions to and from thr fourth state in the model:</p>

<pre><code class="r">trans.rate.mod &lt;- ParDrop(trans.rate, c(4,6,7,8))
print(trans.rate.mod)
</code></pre>

<pre><code>##      (00) (01) (10) (11)
## (00)   NA    3    4    0
## (01)    1   NA    0    0
## (10)    2    0   NA    0
## (11)    0    0    0   NA
</code></pre>

<p>From there the function call is all the same:</p>

<pre><code class="r">MuHiSSE &lt;- MuHiSSE(phy=phy, data=states.trans, f=f, turnover=turnover, 
                     eps=extinction.fraction, hidden.states=FALSE, 
                     trans.rate=trans.rate.mod)
</code></pre>

<p>If you wanted to set up a three-state model, but include hidden states, you would do the following:</p>

<pre><code class="r">turnover &lt;- c(1,2,3,0, 4,5,6,0)
extinction.fraction &lt;- c(1,1,1,0, 1,1,1,0)
f = c(1,1,1,0)
trans.rate &lt;- TransMatMakerMuHiSSE(hidden.traits=1)
trans.rate.mod &lt;- ParDrop(trans.rate, c(4,6,7,8,12,14,15,16))
</code></pre>

<h2>Other considerations</h2>

<p>Like with <code>hisse</code> and <code>GeoHiSSE</code>, there are functions available to obtain model averages (i.e., <code>GetModelAveRates()</code>), generate estimates of the uncertainty in the parameter estimates (i.e., <code>SupportRegionMuHiSSE()</code>), calculate the marginal probabilities for states at nodes (i.e., <code>MarginReconMuHiSSE()</code>), plotting the rate variation on the tree (i.e., <code>plot.muhisse.states()</code>), and model-averaging the rates based on the equilibrium frequencies (i.e., <code>GetModelAveEqFreqs()</code>). Users are encouraged to read other vignettes and help pages provided for more information. For more conceptual discussions of these functions and ideas, readers are also encouraged to read Caetano et al. (2018). </p>

<p>One additional item that is worth mentioning. I would recommend users try multiple random starting points when optimizing any given model with <code>MuHiSSE</code>. In Nakov et al. (2018), we found that the default starting values often did not return the highest log likelihood. To alleviate this issue, we performed \(\ge\) 50 maximum likelihood optimizations for each model, each initiated from a distinct starting point. All functions with <code>hisse</code> are provided with <code>starting.vals</code> option for these purposes. In the case of Nakov et al. (2018), we wrote our own custom function, which I have provided below using a MuCID3 model. Note that the following function was designed for multicore use:</p>

<pre><code class="r">StartingValueTry &lt;- function(phy, data, f, trans.rate){

    freqs &lt;- table(apply(data[,2:3], 1, 
                         function(x) switch(paste0(x, collapse=&quot;&quot;), 
                                            &quot;00&quot; = 1, &quot;01&quot; = 2, &quot;10&quot; = 3, &quot;11&quot; = 4)))
    samp.freq.tree &lt;- Ntip(phy) / sum(freqs / f)
    init.pars &lt;- hisse:::starting.point.generator(phy, 4, samp.freq.tree, yule=FALSE)

    turnover &lt;- c(rep(1,4), rep(2,4), rep(3,4))
    eps &lt;- rep(1,length(turnover))
    NewStarting &lt;- function(iteration){
        turn.start &lt;- exp(rnorm(4, log(init.pars[1]+init.pars[5]), 1))
        eps.start &lt;- runif(1, 0, 1)
        trans.start &lt;- exp(rnorm(12, log(init.pars[9])))
        starting.vals &lt;- c(turn.start, rep(eps.start,4), trans.start)
        print(starting.vals)
        tmp &lt;- MuHiSSE(phy, data, f=f, turnover=turnover, eps=eps, trans.rate=trans.rate,
                       hidden.states=TRUE, starting.vals=starting.vals)
        save(tmp, file=paste(&quot;startingValsTest&quot;, iteration, &quot;.Rsave&quot;, sep=&quot;&quot;))
    }
    mclapply(1:50, NewStarting, mc.cores=50)
}
</code></pre>

<h2>References</h2>

<p>Caetano, D.S., B.C. O&#39;Meara, and J.M. Beaulieu. 2018. Hidden state models improve state-dependent diversification approaches, including biogeographic models. Evolution, 72:2308-2324.</p>

<p>FitzJohn R., W.P. Maddison, and S.P. Otto. 2009. Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies, Systematic Biology, 58: 595-611.</p>

<p>FitzJohn R.G. 2012. Diversitree: comparative phylogenetic analyses of diversification in R. Methods in Ecology and Evolution 3:1084-1092.</p>

<p>Herrera-Alsina, L., P. van Els, and R.S. Etienne. 2018. Detecting the dependence of diversification on multiples traits from phylogenetic trees and trait data. Systematic Biology, 68:317-328.</p>

<p>Nakov, T., Beaulieu, J.M., and Alverson, A.J. 2019. Diatoms diversify and turn over faster in freshwater than marine environments. Evolution, doi: <a href="https://doi.org/10.1111/evo.13832">https://doi.org/10.1111/evo.13832</a>.</p>

</body>

</html>
